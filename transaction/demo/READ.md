## 디비, 트랜잭션 알아보기


## 동시성 문제 해결방법
1. synchronized
2. db lock
    - Pessimistic Lock
      - 실제로 데이터에 Lock 을 걸어서 정합성을 맞추는 방법입니다. exclusive lock 을 걸게되며 다른 트랜잭션에서는 lock 이 해제되기전에 데이터를 가져갈 수 없게됩니다.
        데드락이 걸릴 수 있기때문에 주의하여 사용하여야 합니다.
      - 장점 : 충돌이 빈번하게 일어난다면 Optimistic Lock 보다 성능이 좋음, lock을 통해 데이터 정합성이 어느정도 보장됨, lock 때문에 성능이 안좋아질 수 있음.
    - Optimistic Lock 
      - 실제로 Lock 을 이용하지 않고 버전을 이용함으로써 정합성을 맞추는 방법입니다. 먼저 데이터를 읽은 후에 update 를 수행할 때 현재 내가 읽은 버전이 맞는지 확인하며 업데이트 합니다. 내가 읽은 버전에서 수정사항이 생겼을 경우에는 application에서 다시 읽은후에 작업을 수행해야 합니다.
      - 장점: 별도의 Lock을 잡지 않으므로  Pessimistic Lock 보다 성능상 이점이 있다. 단점으로는, 실패했을 때 재시도 로직을 작성해야함 
    - Named Lock 
      - 이름을 가진 metadata locking 입니다. 이름을 가진 lock 을 획득한 후 해제할때까지 다른 세션은 이 lock 을 획득할 수 없도록 합니다. 주의할점으로는 transaction 이 종료될 때 lock 이 자동으로 해제되지 않습니다. 별도의 명령어로 해제를 수행해주거나 선점시간이 끝나야 해제됩니다.

```sql
select
        stock0_.id as id1_0_,
        stock0_.product_id as product_2_0_,
        stock0_.quantity as quantity3_0_ 
    from
        stock stock0_ 
    where
        stock0_.id=? for update -- for update -> lock을 걸고 데이터를 가져오는 부분 
```

## Pessimistic Lock vs Optimistic Lock
```
낙관적락과 비관적락을 사용하는 기준은 "동시에 수정을 하는일이 빈번하게 일어나는가 ?" 입니다.
그렇기때문에 동일한 사례에서도 동시에 수정을 하는일이 적다면 낙관적락을, 동시에 수정하는 상황이 빈번하게 일어난다면 비관적락을 사용한다고 이해하시면 좋을 것 같습니다.
예를들어 1000명의 사용자가 동시에 A 라는 상품을 구매할 때 "충돌이 빈번하게 일어난다" 라고 생각할 수 있을 것 같습니다.
반대로 1000명의 사용자가 A 라는 상품을 구매하지만 구매시간이 각자 다를 때 (예를들어 사용자 1은 1시에, 사용자 2는 1시 1분에 사용자 3은 1시 2분에...) "충돌이 비교적 적게 일어난다" 라고 생각할 수 있을 것 같습니다.
낙관적락의 구현은 JPA 을 사용한다면 크게 어렵지 않게 구현할 수 있기때문에 실무에서도 사용됩니다.
충돌이 빈번하게 일어나는 상황에서 낙관적락을 사용하게 된다면 모든 요청이 완료될때까지 재시도를 수행할 것 입니다.
예를들어 1000 개의 동시수정이 발생한다면 1000 개의 요청이 모두 완료될때까지 재시도를 수행할 것 입니다.
구현마다 다르겠지만 성공할때까지 시도한다고 가정했을 때 데이터베이스에 굉장히 많은 요청을 보내게 될 것입니다.
반면에 비관적락을 사용한다면 lock 을 걸고 수행하기때문에 이후의 요청들은 업데이트가 완료될때까지 기다렸다가 순차적으로 진행하게 됩니다.
이러한 관점에서 봤을 때 충돌가능성이 많다면 비관적락이 더 좋은선택이 될 수 있습니다.

낙관 락과 비관 락은 동시성 제어에 있어서 사용되는 방식 중 하나입니다.
비관적 락은 공유 자원을 사용할 때 다른 쓰레드와 충돌이 발생할 가능성이 높다고 가정하고 그에 따라 공유 자원에 대한 락을 걸어 다른 쓰레드에 대한 접근을 막는 방식입니다. 따라서, 충돌이 빈번하게 일어나는 환경에서 사용하게 되면 효과적일 수 있습니다.
반면에, 낙관적 락은 충돌이 발생하지 않을 것으로 가정하고 그에 따라 공유 자원에 대한 락을 걸지 않고 접근할 수 있습니다. 만약, 다른 쓰레드가 이미 락을 걸어놓은 경우에는 대기하다가 락이 풀리면 자원에 대한 접근을 시도합니다.
실무에서 구체적인 예시를 들면, 낙관적 락은 일반적으로 읽기 비율이 높은 경우에 사용할 수 있습니다. 예를 들어, 게시글을 읽는 쓰레드가 다수 존재하고 드물게, 쓰기 작업은 비교적 발생하는 경우에는 낙관적 락이 효과적일 수 있습니다. 반면에, 쓰기 작업이 빈번하게 발생하는 경우에는 비관적 락을 사용하는 것이 좋습니다.
또한, 실제로 낙관적 락을 구현해서 사용하는 경우도 있습니다. 낙관적 락의 경우, 충돌이 발생하지 않을 것으로 가정하기 때문에 락을 걸지 않다는 것 자체가 성능상 이점을 가질 수 있습니다. 따라서, 낙관적 락을 구현하고 사용하는 것이 효과적일 수 있습니다.
마지막으로, 충돌이 빈번하게 일어난다면 비관적 락이 더 적합한 이유는 충돌이 발생할 가능성이 높다는 것을 가정하고 적극적으로 락을 거는 방식이기 때문입니다. 따라서, 충돌이 발생할 가능성이 높은 경우에는 비관적 락을 사용하는 것이 더 효과적입니다.
```

## redis 동시성 제어
- Lettuce
   - setnx 명령어를 활용하여 분산락 구현
   - spring data redis 를 이용하면 lettuce 가 기본이기때문에 별도의 라이브러리를 사용하지 않아도 된다. 
   - spin lock 방식이기때문에 동시에 많은 스레드가 lock 획득 대기 상태라면 redis 에 부하가 갈 수 있다.
   - spin lock 방식
   - 장점 : 간단히 구현 가능
   - 단점 : spin lock 방식이므로 레디스에 부하가 일어날 수 있음
- Redission
  - pub-sub 기반으로 lock 구현 제공
  - 락 획득 재시도를 기본으로 제공한다. 
  - pub-sub 방식으로 구현이 되어있기 때문에 lettuce 와 비교했을 때 redis 에 부하가 덜 간다. 
  - 별도의 라이브러리를 사용해야한다. 
  - lock 을 라이브러리 차원에서 제공해주기 떄문에 사용법을 공부해야 한다.

```
재시도가 필요한 경우를 예로 들어드리자면 주문할 떄
유저 A 가 로지텍마우스를 구매하였고 동시에 유저 B 도 로지텍마우스를 구매하였습니다.
이럴때는 유저 A 가 먼저 Lock 을 잡고있다면 유저B 는 기다렸다가 재시도를 하여 로지텍마우스를 구매할 수 있게합니다.
재시도가 필요없을경우는 선착순 1명만 로지텍마우스를 구매할 수 있다고 가정합니다.
유저 A 가 로지텍마우스를 구매하고자 Lock 을 획득하였고, 유저 B 가 추후에 로지텍마우스를 구매하고자 Lock 획득을 시도합니다.
유저 A 가 구매를 하고있는중이며 구매는 1명만 할 수 있기때문에 유저 B 는 획득을 시도해봤자 로지텍마우스를 구매할 수 없습니다.
그렇기때문에 Lock 획득 재시도를 할 필요가 없습니다.
```